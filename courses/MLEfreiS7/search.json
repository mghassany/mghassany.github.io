[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Machine Learning",
    "section": "",
    "text": "Welcome! In this course you will learn about the state of the art of Machine Learning and also gain practice implementing and deploying machine learning algorithms.\nThis course is destined for students of Data Science Filière in EFREI Paris engineering school. In Data Science Filière there is the following master programs:\n\nData & Artificial Intelligence\nData Engineering\nBusiness intelligence and Analytics\nBioInformatics\n\nThe aim of Machine Learning is to build computer systems that can adapt to their environments and learn form experience. Learning techniques and methods from this field are successfully applied to a variety of learning tasks in a broad range of areas, including, for example, spam recognition, text classification, gene discovery, financial forecasting. The course will give an overview of many concepts, techniques, and algorithms in machine learning, beginning with topics such as linear regression and classification and ending up with topics such as kmeans and Expectation Maximization. The course will give you the basic ideas and intuition behind these methods, as well as a more formal statistical and computational understanding. You will have an opportunity to experiment with machine learning techniques in R and apply them to a selected problem.\n\n\n\n\n\nSession\nTopic\nSlides\nLab\n\n\n\n\n1\nIntroduction to ML  Regression\n📖\n💻\n\n\n2\nClassification: Logistic Regression & Regularization\n📖\n💻\n\n\n3\nDecision Trees & Random Forests\n📖\n💻\n\n\n4\nIntroduction to Neural Networks & Deep Learning\n📖\n💻\n\n\n5\nProject\n\n💻"
  },
  {
    "objectID": "TD1.html#python-environment",
    "href": "TD1.html#python-environment",
    "title": "Lab1: Linear Regression",
    "section": "Python environment",
    "text": "Python environment\n\n\n\n\n\n\nAnaconda\n\n\n\nDuring this course we are going to use Python as programming language. Anaconda is an open-source distribution for Python. It is used for data science, machine learning, deep learning, etc. It comes with more than 300 libraries for data science. Anaconda helps in simplified package management and deployment.\nTo install it, go to Anaconda website.\nRemark: if you have a Mac with M1 ship, you must install the 2022.05 release of Anaconda: (Anaconda Distribution Now Supporting M1).\n\n\n\n\n\n\n\n\nJupyter\n\n\n\nDuring the labs, you must use Jupyter notebooks. The Jupyter Notebook is the original web application for creating and sharing computational documents. It offers a simple, streamlined, document-centric experience. Jupyter is installed by default when you install Anaconda. You can create notebooks using JupyterLab via your browser or using a text editor like VScode."
  },
  {
    "objectID": "TD1.html#predicting-house-value-boston-dataset",
    "href": "TD1.html#predicting-house-value-boston-dataset",
    "title": "Lab1: Linear Regression",
    "section": "Predicting House Value: Boston dataset",
    "text": "Predicting House Value: Boston dataset\nIn this lab we are going to use a dataset called Boston. It records the median value of houses for 506 neighborhoods around Boston. Our task is to predict the median house value.\nLoading Data\n\n\n\n\n\n\nBoston dataset\n\n\n\nThe dataset is available in scikit-learn or also here 🔗. Notice that the format/approach is not the same. You are free to use any of them, it is up to you to adapt your codes correctly.\nThere is mainly two approaches you need to know for instance:\n\nThe features and the target variable are in the same dataframe. In this case you can use the argument formula = target ~ features in certain fitting functions (like in ols(), imitating R’s programming language functions).\nThe features and the target variable are separated in X and y.\n\n\n\n\n1. Load these necessary libraries for this lab (install them if needed).\n\nimport numpy as np\nimport matplotlib.pyplot as plt \n\nimport pandas as pd  \nimport seaborn as sns \n\n# Run the following line to obtain the matplotlib figures in the notebook\n%matplotlib inline\n\n# We will also use sklearn but we will load the necessary modules when needed\n\n\n\n\n2. Load the Boston dataset.\n\nfrom sklearn.datasets import load_boston\nboston_dataset = load_boston()\n\n3. Print the value of the boston_dataset to understand what it contains.\n\nprint(boston_dataset.keys())\n\ndict_keys(['data', 'target', 'feature_names', 'DESCR', 'filename', 'data_module'])\n\n\n\ndata: contains the information for various houses\ntarget: prices of the house\nfeature_names: names of the features\nDESCR: describes the dataset\n\nTo know more about the features run boston_dataset.DESCR.\nThe prices of the house indicated by the variable MEDV is our target variable and the remaining are the feature variables based on which we will predict the median value of houses in a district.\n3. Load the data into a pandas dataframe using pd.DataFrame. Then print the first 5 rows of the data using head().\n\nboston = pd.DataFrame(boston_dataset.data, columns=boston_dataset.feature_names)\nboston.head()\n\n      CRIM    ZN  INDUS  CHAS    NOX  ...  RAD    TAX  PTRATIO       B  LSTAT\n0  0.00632  18.0   2.31   0.0  0.538  ...  1.0  296.0     15.3  396.90   4.98\n1  0.02731   0.0   7.07   0.0  0.469  ...  2.0  242.0     17.8  396.90   9.14\n2  0.02729   0.0   7.07   0.0  0.469  ...  2.0  242.0     17.8  392.83   4.03\n3  0.03237   0.0   2.18   0.0  0.458  ...  3.0  222.0     18.7  394.63   2.94\n4  0.06905   0.0   2.18   0.0  0.458  ...  3.0  222.0     18.7  396.90   5.33\n\n[5 rows x 13 columns]\n\n\nWe can see that the target value MEDV is missing from the data. We create a new column of target values and add it to the dataframe.\n\nboston['MEDV'] = boston_dataset.target\n\nRemark: the previous steps we evitable if we loaded the data from csv given above using pd.read_csv()."
  },
  {
    "objectID": "TD1.html#data-preprocessing",
    "href": "TD1.html#data-preprocessing",
    "title": "Lab1: Linear Regression",
    "section": "Data preprocessing",
    "text": "Data preprocessing\n4. Check if there are any missing values in the data.\n\n\n\nExploratory Data Analysis\nExploratory Data Analysis is a very important step before training the model. In this section, we will use some visualizations to understand the relationship of the target variable with other features.\n5. Plot the distribution of the target variable MEDV. You can use the distplot() function from the seaborn library.\n\n\n\n6. Calculate the correlation matrix and visualize it. Name the features that are highly correlated with the target variable.\n\n\n\n\n\n\n\n\n\nCorrelation\n\n\n\nThe correlation coefficient ranges from -1 to 1. If the value is close to 1, it means that there is a strong positive correlation (linear tendancy) between the two variables. When it is close to -1, the variables have a strong negative correlation.\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor a linear regression model, we select the features which have a high correlation with the target variable. Anyway there is some feature selection techniques you may use, one of them is Backward selection:\nBackward selection:\n\nStart with all variables in the model.\nRemove the variable with the largest p-value — that is, the variable that is the least statistically significant.\nThe new \\((p − 1)\\)-variable model is fit, and the variable with the largest p-value is removed.\nContinue until a stopping rule is reached. For instance, we may stop when all remaining variables have a significant p-value defined by some significance threshold.\n\n\n\n7. Check for multi-colinearity between the features. More specifically RAD and TAX.\n\n\n\n\n\n\nTip\n\n\n\nWe should not select colinear features together for training the model. Check this link for one explanation.\n\n\nSplitting the data into training and testing sets\nTrain test split is a model validation procedure that allows you to simulate how a model would perform on new/unseen data. Here is how the procedure works:\n\n8. Split the data into training and testing sets. We are going to train the model with 80% of the samples and test with the remaining 20%. Use train_test_split() function provided by scikit-learn library\n\nfrom sklearn.model_selection import train_test_split\n\n# complete the code\nX = ...\nY = ...\n\nX_train, X_test, Y_train, Y_test = ...(, , test_size = ..., random_state=5)\n\n# print the shapes to verify if the splitting has occured properly\nprint(X_train.shape)\nprint(X_test.shape)\nprint(Y_train.shape)\nprint(Y_test.shape)"
  },
  {
    "objectID": "TD1.html#simple-linear-regression-model",
    "href": "TD1.html#simple-linear-regression-model",
    "title": "Lab1: Linear Regression",
    "section": "\nSimple Linear Regression model",
    "text": "Simple Linear Regression model\nIn this part, we are going to build a simple linear regression model. We will choose LSTAT as a feature.\n9. Plot MEDV in function of LSTAT.\n10. Fit a simple regression model using LinearRegression() from sklearn.linear_model.\n\nfrom sklearn.linear_model import LinearRegression\n\nslm = LinearRegression()\nslm.fit(..., ...)\n\n11. The LinearRegression() module from scikit-learn does not provide a statistical summary of the regression model. To obtain this summary, re-fit a model using ols() from statsmodels. Analyse the p-value from the summary and interpret.\n12. Plot the regression model.\nModel evaluation\n13. Evaluate the model using MSE (Mean Squarred Error) and R2-score.\n\nfrom sklearn.metrics import mean_squared_error\n\n# train error (MSE)\ny_train_predict = slm.predict(...)\nmse_train = ...(..., ...)\n\nprint(\"The model performance for training set\")\nprint(\"--------------------------------------\")\nprint('MSE is {}'.format(mse_train))\n\n\n# test error\ny_test_predict = slm.predict(...)\nmse_test = mean_squared_error(..., ...)\nr2 = r2_score(..., ...)\n\nprint(\"The model performance for testing set\")\nprint(\"--------------------------------------\")\nprint('MSE is {}'.format(mse_test))\nprint('R2 score is {}'.format(r2))\n\n14. According to the plot in 9, the relationship between LSTAT and MEDV is not linear. Let’s try a transformation of our explanatory variable LSTAT. Re-do the steps from 9 to 13 but using the log of LSTAT. Do you obtain a better model?"
  },
  {
    "objectID": "TD1.html#multiple-linear-regression-model",
    "href": "TD1.html#multiple-linear-regression-model",
    "title": "Lab1: Linear Regression",
    "section": "Multiple Linear Regression model",
    "text": "Multiple Linear Regression model\n15. Train a new model using all the variables of the dataset. Evalute the performance of the model.\n16. Which features are significant for the model?\n17. Apply backward selection to fit a model with the best subset of features.\n18. Is the new model better than the last one with all the features?\n19. In the last model we didn’t transform LSTAT. Re train the model using log(LSTAT) instead of LSTAT. Does this new model performs better?"
  },
  {
    "objectID": "TD1.html#anova-analysis-of-variances",
    "href": "TD1.html#anova-analysis-of-variances",
    "title": "Lab1: Linear Regression",
    "section": "ANOVA (ANalysis Of VAriances)",
    "text": "ANOVA (ANalysis Of VAriances)\nIn this last part we will apply an analysis of variances (ANOVA) in order to test if there is a significant difference of means between two groups \\(i\\) and \\(j\\) (Consider group \\(i\\) is the suburbs bounding the river and \\(j\\) the suburbs which not). The hypotheses are\n\\[ H_0 : \\mu_i = \\mu_j \\]\n\\[ H_1 : \\mu_i \\neq \\mu_j \\]\nWhere \\(\\mu_i\\) is the mean of MEDV in group \\(i\\).\n\n\n\n\n\n\nAnova\n\n\n\nThis analysis can be conducted during the exploratory data analysis part especially when the target is continuous and a feature is discrete.\n\n\n20. In the Boston data set there is a categorical variable CHAS which corresponds to Charles River (= 1 if a suburb bounds the river; 0 otherwise). How many of the suburbs in this data set bound the Charles river?\n\n\n\n21. Create Boxplots of the median value of houses with respect to the variable CHAS. Do we observe some difference between the median value of houses with respect to the neighborhood to Charles River?\n\n\n\n22. Calculate \\(\\mu_i\\) and \\(\\mu_j\\).\n\n\n\n23. Apply an ANOVA test of MEDV with respect to CHAS. What do you conclude ?"
  },
  {
    "objectID": "TD2.html",
    "href": "TD2.html",
    "title": "Lab2: Logistic Regression & Regularization",
    "section": "",
    "text": "In this lab, you will implement logistic regression and apply it to two different datasets.\nBefore we begin with the exercises, we need to import all libraries required for this programming exercise. Throughout the course, we will be using numpy for all arrays and matrix operations, and matplotlib for plotting. In this assignment, we will also use scipy, which contains scientific and numerical computation functions and tools.\n\n# Scientific and vector computation for python\nimport numpy as np\n\n# Plotting library\nimport matplotlib.pyplot as plt\n\n# Optimization module in scipy\nfrom scipy import optimize\n\n# do not forget to tell matplotlib to embed plots within the notebook\n%matplotlib inline"
  },
  {
    "objectID": "TD2.html#logistic-regression",
    "href": "TD2.html#logistic-regression",
    "title": "Lab2: Logistic Regression & Regularization",
    "section": "Logistic Regression",
    "text": "Logistic Regression\nIn this part of the exercise, you will build a logistic regression model to predict whether a student gets admitted into a university. Suppose that you are the administrator of a university department and you want to determine each applicant’s chance of admission based on their results on two exams. You have historical data from previous applicants that you can use as a training set for logistic regression. For each training example, you have the applicant’s scores on two exams and the admissions decision.\nYour task is to build a classification model that estimates an applicant’s probability of admission based the scores from those two exams.\n1. Load the data tp2data1.txt from here  using the loadtxt() from numpy. The first two columns contains the exam scores and the third column contains the label. Then separate the features from label. Name the feature matrix X and the label y.\n\n\n\n\n\n\n2. Print the first 5 samples from X and y.\nVisualizing the data\n3. Display the data on a 2-dimensional plot where the axes are the two exam scores, and the positive and negative examples are shown with different colors (or markers).\nYou should produce something like this:\n\n\n\n\n\n\n\n\nImplementation\nSigmoid function\nRecall that the logistic regression hypothesis is defined as:\n\\[ h_\\omega(x) = g(\\omega^T x)\\]\nwhere function \\(g\\) is the sigmoid function. The sigmoid function is defined as:\n\\[g(z) = \\frac{1}{1+e^{-z}}\\]\n4. Implement the sigmoid function so it can be called by the rest of your program. When you are finished, try testing a few values by calling sigmoid(x) in a new cell. For large positive values of x, the sigmoid should be close to 1, while for large negative values, the sigmoid should be close to 0. Evaluating sigmoid(0) should give you exactly 0.5. Your code should also work with vectors and matrices. For a matrix, your function should perform the sigmoid function on every element.\n5. Plot the sigmoid function, like this:\n\n\n\n\n\n\n\n\n\n\n\nCost function and gradient\n6. Before proceeding, add the intercept term to X. (hint: you can use np.concatenate or np.hstack)\n\n\n\n7. Implement the cost function and its gradient for logistic regression.\nRecall that the cost function for logistic regression is\n\\[ J(\\omega) = \\frac{1}{m} \\sum_{i=1}^{m} \\left[ -y^{(i)} \\log\\left(h_\\omega\\left( x^{(i)} \\right) \\right) - \\left( 1 - y^{(i)}\\right) \\log \\left( 1 - h_\\omega\\left( x^{(i)} \\right) \\right) \\right]\\]\nRecall that the gradient of the cost is a vector of the same length as \\(\\omega\\) where the \\(j^{th}\\) element (for \\(j = 0, 1, \\cdots , n\\)) is defined as follows:\n\\[ \\frac{\\partial J(\\omega)}{\\partial \\omega_j} = \\frac{1}{m} \\sum_{i=1}^m \\left( h_\\omega \\left( x^{(i)} \\right) - y^{(i)} \\right) x_j^{(i)} \\]\n\n\n\n8. Call your implemented function using two test cases for \\(\\omega\\). You should see that the cost is about 0.693 for \\(\\omega = (0,0,0)\\).\n\n\n\n\n\n\nLearning the parameters\nLearning parameters using your implemented Gradient Descent\n9. Implement the gradient descent algorithm for logistic regression: write a cost function and calculate its gradient, then take a gradient descent step accordingly in order to find the optimal parameters. Run it on the training set. Print the results (the parameters values and the cost function).\nLearning parameters using scipy.optimize\nIn this part you will use the scipy.optimize module. SciPy is a numerical computing library for python. It provides an optimization module for root finding and minimization. As of scipy 1.0, the function scipy.optimize.minimize is the method to use for optimization problems(both constrained and unconstrained).\nFor logistic regression, you want to optimize the cost function \\(J(\\omega)\\) with parameters \\(\\omega\\). Concretely, you are going to use optimize.minimize to find the best parameters \\(\\omega\\) for the logistic regression cost function, given a fixed dataset (of X and y values). You will pass to optimize.minimize the following inputs:\n\n\ncostFunction: A cost function that, when given the training set and a particular \\(\\omega\\), computes the logistic regression cost and gradient with respect to \\(\\omega\\) for the dataset (X, y). It is important to note that we only pass the name of the function without the parenthesis. This indicates that we are only providing a reference to this function, and not evaluating the result from this function.\n\ninitial_omega: The initial values of the parameters we are trying to optimize.\n\n(X, y): These are additional arguments to the cost function.\n\njac: Indication if the cost function returns the Jacobian (gradient) along with cost value. (True)\n\nmethod: Optimization method/algorithm to use\n\noptions: Additional options which might be specific to the specific optimization method. In the following, we only tell the algorithm the maximum number of iterations before it terminates.\n\nIf you have calculated the cost function correctly, optimize.minimize will converge on the right optimization parameters and return the final values of the cost and \\(\\omega\\) in a class object. Notice that by using optimize.minimize, you did not have to write any loops yourself, or set a learning rate like you did for gradient descent. This is all done by optimize.minimize: you only needed to provide a function calculating the cost and the gradient.\nIn the following, a code written to call optimize.minimize with the correct arguments.\n\n# set options for optimize.minimize\noptions= {'maxiter': 400}\n\n# see documention for scipy's optimize.minimize  for description about\n# the different parameters\n# The function returns an object `OptimizeResult`\n# We use truncated Newton algorithm for optimization which is \n# equivalent to MATLAB's fminunc\n# See https://stackoverflow.com/questions/18801002/fminunc-alternate-in-numpy\n\n# initial_omega = np.array([0, 0, 0])\n\nres = optimize.minimize(costFunction,\n                        initial_omega,\n                        (X_train, y),\n                        jac=True,\n                        method='TNC',\n                        options=options)\n\n# the fun property of `OptimizeResult` object returns\n# the value of costFunction at optimized omega\ncost = res.fun\n\n# the optimized omega is in the x property\nomega = res.x\n\n# Print omega to screen\nprint('Cost at omega found by optimize.minimize: {:.3f}'.format(cost))\nprint('Expected cost (approx): 0.203\\n');\n\nprint('omega:')\nprint('\\t[{:.3f}, {:.3f}, {:.3f}]'.format(*omega))\nprint('Expected omega (approx):\\n\\t[-25.161, 0.206, 0.201]')\n\n10. Run the code above on your cost function and verify that you obtain the correct (or almost) values.\n\n\n\nPlotting the decision boundary\nSince the decision boundary of logistic regression is a linear (you know that right?) and the dimension of the feature space here is 2, the decision boundary in this 2-dimensional space is a line that separates the predicted classes “0” and “1”.\nFor logistic regression, we predict \\(y=1\\) if \\(\\omega^T X \\geq 0\\) (right side of the line) and \\(y=0\\) if \\(\\omega^T X \\lt 0\\) (left side of the line). Where\n\\[\n\\omega = \\begin{pmatrix} \\omega_0 \\\\ \\omega_1 \\\\ \\omega2 \\end{pmatrix} \\,\\, \\text{and} \\,\\, X = \\begin{pmatrix}\n  1 \\\\\n  X_1 \\\\\n  X_2\n  \\end{pmatrix}\n\\]\nSo we predict \\(y=1\\) if \\(\\omega_0 + \\omega_1 X_1 + \\omega_2 X_2 \\geq 0\\) which means that the equation of the decision boundary (a line here) is \\(X_2 = - \\frac{\\omega_1}{\\omega_2}X_1 - \\frac{\\omega_0}{\\omega_2}\\)\n11. Plot the decision boundary obtained with logistic regression.\nEvaluating logistic regression\n12. After learning the parameters, you can use the model to predict whether a particular student will be admitted. For a student with an Exam 1 score of 45 and an Exam 2 score of 85, you should expect to see an admission probability of 0.776. Another way to evaluate the quality of the parameters we have found is to see how well the learned model predicts on our training set. Write a function predict that will produce “1” or “0” predictions given a dataset and a learned parameter vector \\(\\omega\\).\n13. Calculate the confusion matrix, and use it to calculate the training accuracy of your classifier and the F1 score.\n14. In order to verify that your line (decision boundary) is well plotted, color the points on the last Figure with respect to the predicted response.\n15. Now make the same plot but color the points with respect to their real labels. From this figure, count the number of the false positive predictions.\nplotDecisionBoundary function\nFor the rest, use the following function (or modify it to adapt it) for plotting the decision boundary.\n\ndef plotDecisionBoundary(omega, X, y):\n    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),\n                         np.arange(y_min, y_max, 0.1))\n    X_plot = np.c_[xx.ravel(), yy.ravel()]\n    X_plot = np.hstack((np.ones((X_plot.shape[0], 1)), X_plot))\n    y_plot = np.dot(X_plot, omega).reshape(xx.shape)\n    \n    plt.figure()\n    plt.scatter(X[y == 1][:, 0], X[y == 1][:, 1], label=\"Admitted\")\n    plt.scatter(X[y == 0][:, 0], X[y == 0][:, 1], label=\"Not admitted\")\n    plt.contour(xx, yy, y_plot, levels=[0])\n    plt.xlabel(\"Exam 1 score\")\n    plt.ylabel(\"Exam 2 score\")\n    plt.legend()\n    plt.show()\n\n\nplotDecisionBoundary(res.x, X, y)\n\n\n\n0.20365864300942144\n\n\n[-24.13930679   0.19805053   0.19320881]"
  },
  {
    "objectID": "TD2.html#regularized-logistic-regression",
    "href": "TD2.html#regularized-logistic-regression",
    "title": "Lab2: Logistic Regression & Regularization",
    "section": "Regularized logistic regression",
    "text": "Regularized logistic regression\nIn this part of the exercise, you will implement regularized logistic regression to predict whether microchips from a fabrication plant passes quality assurance (QA). During QA, each microchip goes through various tests to ensure it is functioning correctly.\nSuppose you are the product manager of the factory and you have the test results for some microchips on two different tests. From these two tests, you would like to determine whether the microchips should be accepted or rejected. To help you make the decision, you have a dataset of test results on past microchips, from which you can build a logistic regression model.\n2.1. Load the data in file tp2data2.txt from from here . Separate the features from the labels in two differents objects.\n\n\n\n2.2. Visualize the data in a 2-dimensional plot. Color the point with respect to their labels. What do you notice ?\n\n\n\n\n\nFeature mapping\nOne way to fit the data better is to create more features from each data point. In the function mapFeature defined below, we will map the features into all polynomial terms of \\(x_1\\) and \\(x_2\\) up to the sixth power.\n\\[\\text{mapFeature}(x) = \\begin{bmatrix} 1 & x_1 & x_2 & x_1^2 & x_1 x_2 & x_2^2 & x_1^3 & \\dots & x_1 x_2^5 & x_2^6 \\end{bmatrix}^T\\]\n\ndef mapFeature(X1, X2, degree=6):\n    \"\"\"\n    Maps the two input features to quadratic features used in the regularization exercise.\n\n    Returns a new feature array with more features, comprising of\n    X1, X2, X1.^2, X2.^2, X1*X2, X1*X2.^2, etc..\n\n    Parameters\n    ----------\n    X1 : array_like\n        A vector of shape (m, 1), containing one feature for all examples.\n\n    X2 : array_like\n        A vector of shape (m, 1), containing a second feature for all examples.\n        Inputs X1, X2 must be the same size.\n\n    degree: int, optional\n        The polynomial degree.\n\n    Returns\n    -------\n    : array_like\n        A matrix of of m rows, and columns depend on the degree of polynomial.\n    \"\"\"\n    if X1.ndim > 0:\n        out = [np.ones(X1.shape[0])]\n    else:\n        out = [np.ones(1)]\n\n    for i in range(1, degree + 1):\n        for j in range(i + 1):\n            out.append((X1 ** (i - j)) * (X2 ** j))\n\n    if X1.ndim > 0:\n        return np.stack(out, axis=1)\n    else:\n        return np.array(out)\n\nAs a result of this mapping, our vector of two features (the scores on two QA tests) has been transformed into a 28-dimensional vector. A logistic regression classifier trained on this higher-dimension feature vector will have a more complex decision boundary and will appear nonlinear when drawn in our 2-dimensional plot.\nWhile the feature mapping allows us to build a more expressive classifier, it also more susceptible to overfitting.\nIn the next parts of the exercise, you will implement regularized logistic regression to fit the data and also see for yourself how regularization can help combat the overfitting problem.\n2.3. Apply the mapFeature() function on the dataset. Verify that you get a 28-dimensional vector.\n\n\n\nCost function and gradient\nRecall that the regularized cost function in logistic regression is\n\\[ J(\\omega) = \\frac{1}{m} \\sum_{i=1}^m \\left[ -y^{(i)}\\log \\left( h_\\omega \\left(x^{(i)} \\right) \\right) - \\left( 1 - y^{(i)} \\right) \\log \\left( 1 - h_\\omega \\left( x^{(i)} \\right) \\right) \\right] + \\frac{\\lambda}{2m} \\sum_{j=1}^n \\omega_j^2 \\]\nNote that we do not regularize the parameters \\(\\omega_0\\). The gradient of the cost function is a vector where the \\(j^{th}\\) element is defined as follows:\n\\[ \\frac{\\partial J(\\omega)}{\\partial \\omega_0} = \\frac{1}{m} \\sum_{i=1}^m \\left( h_\\omega \\left(x^{(i)}\\right) - y^{(i)} \\right) x_j^{(i)} \\qquad \\text{for } j =0 \\]\n\\[ \\frac{\\partial J(\\omega)}{\\partial \\omega_j} = \\left( \\frac{1}{m} \\sum_{i=1}^m \\left( h_\\omega \\left(x^{(i)}\\right) - y^{(i)} \\right) x_j^{(i)} \\right) + \\frac{\\lambda}{m}\\omega_j \\qquad \\text{for } j \\ge 1 \\]\n2.4. Complete the function costFunctionReg() below. This function computes and returns the cost function and gradient for regularized logistic regression.\n\ndef costFunctionReg(omega, X, y, lambda_):\n    \"\"\"\n    Compute cost and gradient for logistic regression with regularization.\n    \n    Parameters\n    ----------\n    omega : array_like\n        Logistic regression parameters. A vector with shape (n, ). n is \n        the number of features including any intercept. If we have mapped\n        our initial features into polynomial features, then n is the total \n        number of polynomial features. \n    \n    X : array_like\n        The data set with shape (m x n). m is the number of examples, and\n        n is the number of features (after feature mapping).\n    \n    y : array_like\n        The data labels. A vector with shape (m, ).\n    \n    lambda_ : float\n        The regularization parameter. \n    \n    Returns\n    -------\n    J : float\n        The computed value for the regularized cost function. \n    \n    grad : array_like\n        A vector of shape (n, ) which is the gradient of the cost\n        function with respect to omega, at the current values of omega.\n    \n    Instructions\n    ------------\n    Compute the cost `J` of a particular choice of omega.\n    Compute the partial derivatives and set `grad` to the partial\n    derivatives of the cost w.r.t. each parameter in omega.\n    \"\"\"\n    # Initialize some useful values\n    m = y.size  # number of training examples\n\n    # You need to return the following variables correctly \n    J = 0\n    grad = np.zeros(omega.shape)\n\n    # ===================== YOUR CODE HERE ======================\n\n    \n    \n    # =============================================================\n    return J, grad\n\n\n\n\n2.5. Once you are done with the costFunctionReg, call it using the initial value of \\(\\omega\\) (initialized to all zeros), and also another test case where \\(\\omega\\) is all ones. The code is given below with the expected values. You should obtain the same values.\n\n# Initialize fitting parameters\n# X here has 28 columns\ninitial_omega = np.zeros(X.shape[1])\n\n# Set regularization parameter lambda to 1\n# DO NOT use `lambda` as a variable name in python\n# because it is a python keyword\nlambda_ = 1\n\n# Compute and display initial cost and gradient for regularized logistic\n# regression\ncost, grad = costFunctionReg(initial_omega, X, y, lambda_)\n\nprint('Cost at initial omega (zeros): {:.3f}'.format(cost))\nprint('Expected cost (approx)       : 0.693\\n')\n\nprint('Gradient at initial omega (zeros) - first five values only:')\nprint('\\t[{:.4f}, {:.4f}, {:.4f}, {:.4f}, {:.4f}]'.format(*grad[:5]))\nprint('Expected gradients (approx) - first five values only:')\nprint('\\t[0.0085, 0.0188, 0.0001, 0.0503, 0.0115]\\n')\n\n\n# Compute and display cost and gradient\n# with all-ones omega and lambda = 10\ntest_omega = np.ones(X.shape[1])\ncost, grad = costFunctionReg(test_omega, X, y, 10)\n\nprint('------------------------------\\n')\nprint('Cost at test omega    : {:.2f}'.format(cost))\nprint('Expected cost (approx): 3.16\\n')\n\nprint('Gradient at test omega - first five values only:')\nprint('\\t[{:.4f}, {:.4f}, {:.4f}, {:.4f}, {:.4f}]'.format(*grad[:5]))\nprint('Expected gradients (approx) - first five values only:')\nprint('\\t[0.3460, 0.1614, 0.1948, 0.2269, 0.0922]')\n\nLearning parameters using scipy.optimize.minimize\n\n2.6. Use optimize.minimize to learn the optimal parameters \\(\\omega\\).\n\n\n\nPlotting the decision boundary\n2.7. To visualize the model learned by this classifier use the function plotDecisionBoundary to plot the (non-linear) decision boundary that separates the positive and negative examples.\n\nIn plotDecisionBoundary, we plot the non-linear decision boundary by computing the classifier’s predictions on an evenly spaced grid and then and draw a contour plot where the predictions change from y = 0 to y = 1.\n\nExtra\nTry out different regularization parameters for the dataset to understand how regularization prevents overfitting.\nNotice the changes in the decision boundary as you vary \\(\\lambda\\). With a small \\(\\lambda\\), you should find that the classifier gets almost every training example correct, but draws a very complicated boundary, thus overfitting the data.\nCredits\n\nThis lab is hugely inspired from Andrew Ng’s Machine Learning course. Supplementary material from dibgerge’s github was used."
  },
  {
    "objectID": "TD3.html",
    "href": "TD3.html",
    "title": "Lab3: Decision Trees and Random Forests",
    "section": "",
    "text": "To be appeared soon .."
  },
  {
    "objectID": "TD4.html",
    "href": "TD4.html",
    "title": "Lab4: Neural Networks",
    "section": "",
    "text": "To be appeared soon .."
  }
]